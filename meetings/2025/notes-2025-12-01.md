# 1 December 2025 | MessageFormat Working Group Teleconference

Attendees:

- Eemeli Aro \- Mozilla (EAO)  
- Mihai Niță \- Google (MIH)  
- Tim Chevalier \- Igalia (TIM)  
- Shane Carr \- Google (SFC)  
- Richard Gibson \- OpenJSF (RGN)

**Scribe:** TIM  

## Infoshare

* EAO: TPAC went quite well. The biggest thing coming out of it is that W3C i18n picked up incubation of the message resource format. Specific impetus was that I also got a decent amount of buy-in on starting to work on DOM localization – building on top of Unicode MessageFormat to affect HTML. Requires the format for message resources, figuring out a new WG under W3C. That’s ongoing. MIH, do you know anyone at Google who I should ping about this?  
* MIH: Not really. Shane might know more.   
* SFC: Sounds like there’s more interest on W3C side than Unicode  
* EAO: I’m trying to figure out who should be made aware that some work around this is starting. Going a bit beyond localization/i18n as the focus. People interested in ensuring that a file format meant for use in browsers is performant and can be easily parsed and has good failure modes. That sort of thinking, who should I/could I involve from the Google Chromium side?  
* SFC: I think that once there’s a proposal at a stage where it can be reviewed, you’ll be able to get the right people involved. 

## Updates from Implementers

* TIM: Still waiting for review  
* MIH: Pinged Frank. Will ping further  
* EAO: Released [npmjs.com/package/messageformat](https://www.npmjs.com/package/messageformat) as 4.0.0 with full support for the LDML 48 version.  
* MIH: ICU4J 78.1 matches LDML 48  
* EAO: Thinking about a Python implementation  
* EAO: Shane, do you know anything about ICU4X and MF?  
* SFC: Seems to be a hot potato. Right now in Zibi’s hands. Not that it isn’t a priority, just that we haven’t had a lot of time

## Datetime Formatting

* EAO: Now that we’ve got percent and currency sorted, it’s just the hard stuff that we’re left with, in terms of open questions and in-progress work. Specifically unit and datetime formatting. How are we going to advance these? What is the status of semantic skeletons? Is it finally final, or still in progress?  
* SFC: The status is approximately the same as it was a few months ago, because I’ve been focused much more on other things. There’s still a number of open issues on semantic skeletons, status hasn’t changed much. One thing did change \[cut off\]  
* EAO: LDML still has a note saying semantic skeletons are a technical preview and should not be considered stable.  
* SFC: ICU4X shipped(?)  
* EAO: So for us, datetime formatting is stuck at draft until whatever release comes after the release where semantic skeletons are stable. So we won’t progress from the current point until maybe next fall’s release, if semantic skeletons hit stable in spring. We could theoretically make it into the same release but that seems like it would require a lot of work.  
* SFC: It’s on my todo list, I’ll make sure it’s on my 2026 plan as well. If anyone wants to help on that, you’re welcome to collaborate.  
* EAO: What is the remaining work specifically that other people could help with?  
* SFC: Some design questions involving – biggest one is ?? for individual fields. A couple other smaller design questions… once the design questions are resolved we can work on implementation of it.  
* EAO: What’s the place where the discussion and consideration of these design issues is happening, or is there any such place? A GitHub repo that is the appropriate place for this?  
* SFC: Just JIRA. We could move it somewhere else if that’s better.  
* EAO: Any other thoughts?  
* MIH: Either we wait for that spec to become final, or… I don’t know.

## Unit Formatting

* EAO: Unit formatting is most dependent as far as I know on figuring out how much we’re forcing the division of what is the thing being formatted in the syntax, vs. what we allow to vary at runtime. Do we have alignment on requiring the syntax to effectively end up defining which kind of unit is being formatted? Or do we still want that to be possibly definable at runtime?  
* MIH: I definitely think it should be possible to define at runtime  
* EAO: So here we’re talking about defining in a message that a unit is a unit of length rather than a unit of mass.  
* MIH: The use case for that is a lot slimmer, I think. Meters vs. yards should be runtime. Switching between length and mass, probably not.  
* EAO: I agree…  
* RGN: In practice, if it degrades the user experience too much to draw that distinction, my opinion would flip. Don’t want to force authors to have to look up and declare the kind of measurement that they just want to express.  
* SFC: I agree with requiring the dimension to be specified. It would degrade the user experience, I don’t see any way around that. Is the degradation to user experience worth the significant savings of data loading at runtime for implementations like ICU4X that need to run on low-resource devices? I think it is.  
* MIH: The whole idea of data slicing and loading and the burden that puts on ICU4X – I’m sympathetic, but as a user, you give me the freedom and you tell me if you want to format some dimension and you don’t tell me what it is, I’m going to load all the data. If you want to save some data, go through the effort and specify the unit type. That doesn’t mean you leave it out of the spec or the user cannot do it. You do it, if you know what you are doing, you cut data; if you don’t want to go through the trouble, we’re going to load a lot more.   
* SFC: Need to drop  
* MIH: It shouldn’t influence the MF standard to the point of “no, sorry, cannot do this.” Should be able to say “it’s going to cost you, but you can do it.”  
* EAO: Y’all have been talking about users. The way I’m looking at this, I’m having a hard time seeing why requiring the dimensionality of the unit in the syntax – it would improve things for the translator. Seeing that this unit expression is formatting a length and this one is formatting a mass, even if you don’t know the units, it seems like it would make things better for the translator experience.  
* RGN: You can say that when it’s simple things like length and mass, but what about when you get to magnetic flux per unit area? Not all dimensionality is so straightforward.  
* EAO: If it is, like, magnetic flux per unit area, is it something where at runtime you’re going to be changing the unit of what you’re formatting?  
* RGN: Possibly; or with something like pressure. Pressure is not fundamental, it’s force-per-area.  
* MIH: And I can imagine places where you really mix up stuff, like recipes and cooking. 1 kilo of milk vs. 1 liter of milk. Different cultures might do different things. You really change the type, one is a volume and the other is a mass. Not technically correct, but some people do recipes that way and some do recipes the other way.  
* RGN: You’re not wrong, I’ve seen it all over the place. Some recipes provide multiple distinct dimensionality to accommodate those differences. Don’t know what it would look like in a message template.  
* MIH: People mix and match stuff  
* EAO: That’s fair. The cooking example specifically, constructing a sentence “add \[unit\] of flour” is potentially going to be at times adding 1 cup of flour or adding 150 grams. Sometimes a recipe is using volume and sometimes mass. That is for me the most convincing argument thus far about not limiting it to only one.   
* MIH: But as long as we make it clear that if you don’t specify the measurement type, we load a lot of data, tough luck, I don’t see a reason to make it impossible in the MF spec.  
* EAO: On the other hand, I think it’s rare and specific – flour in cooking – where this would show up, difference in units.  
* MIH: In Romanian recipes I’ve rarely seen teaspoons/spoons/cups. That’s a very American thing to me.  
* RGN: Also seen it with liquids. Adding things by mass, including milk or water or whatever.   
* EAO: Cooking-related messages specifically is I think a relatively common use case that we can imagine for not requiring the unit format to enforce defining the type of the unit. However, I would – if the ICU4X argument against this can be shown to have a significant cost to all users of the interface, I would be willing to compromise on this. But this is a conversation for which we’re going to need Shane.  
* MIH: If the price is basically “if you’re lazy and don’t specify the unit type, then you load more”, I don’t think that affects a lot of users. Or if you need to, not if you’re lazy.  
* EAO: This reminds me of another thing coming out of TPAC. I ended up hosting a breakout session on a proposal to add an “amount” element to HTML. Somewhat related to a parallel discussion of adding an Amount primordial to JS. Specifically the amount being added to HTML is an amount that would be supporting unit conversion relatively soon in its existence. This is making it easier for me to start considering actually ratifying something like usage in the unit formatting that we end up doing.   
* MIH: The amount was a bit funny. Shane shared the design doc with the position he’s taking and I’m confused. It seems like it’s trying to cram in the amounts stuff about precision and stuff about the units – a numerical value and some kind of unit saying what this number represents. I was confused about all of the attempts to put some precision in that whole thing. Should be part of the numeric thing. The fact that you cut around decimals or not, it’s part of the formatting, not the amount itself. I think JS needs a better numeric type that has better precision than the floats that are there today.   
* EAO: This is indeed a bit sidetracky. The relevant thing apart from the amount discussion is considering usage as a parameter we define for unit formatting in MF. Do I understand right that that’s already well-supported in the ICU implementations?  
* MIH: Yes. I’ve discovered cases where the API is confusing and I have to figure out how it works every time I use it, but whatever.  
* EAO: Takeaways are to raise with ICU4X the concern that there is an identifiable cost to requiring the type of unit to be defined. Also defining usage would be interesting and I don’t know how the usage definition would then link up with the API design for the type of unit that we’re talking about. Whether it’s like one field or multiple fields.  
* MIH: I think the usage drags with it the unit type sometimes. Think about cooking, which means temperature. Canada has that weird thing where they do cooking in Fahrenheit and weather in Celsius. If you say “cooking” you just bring one.  
* EAO: UK is also funky about person mass/person weight.   
* MIH: That’s another one where a lot of people mix stuff. Weight vs. mass. It’s kilos, that’s my weight, but no, that’s my mass. Nobody makes that distinction. If you bring that up in a discussion…  
* EAO: Good thing is that we don’t need to have that discussion because we’ll rely on whatever is in CLDR.  
* RGN: Is that true for all of them?  
* EAO: What do you mean?  
* RGN: Even with something simple like length, the domain in which you’re orienting it can change the unit basis. Nuclear physicists might care about angstroms, others about light-years and parsecs, still others about meters.   
* MIH: I don’t know how they slice it  
* RGN: CLDR just groups all of them together and bundles them along  
* EAO: Then there’s the thing where if you’re defining usage and defining a locale, you are actually defining – when you know what the message is and the syntax has all of those things, you know the locale, then you know what units you’ll use for the formatting.  
* MIH: If you specify the usage, right, not the unit. If you say temperature in Canada, you don’t know.  
* EAO: Person height is another one  
* MIH: The usage narrows things down more than the unit type measurement.  
* RGN: Dramatically so  
* MIH: Google Maps distances – I don’t think they give you stuff in centimeters.  
* EAO: I think we should review what we have written about `:unit` at some point, but I don’t think any of us have looked at it recently. Probably I ought to file an issue on the ICU4X repo about `:unit` splitting, so there’s a specific place to have a discussion together with ICU4X, or with Shane on this call if that’s how it ends up, so we can get resolution on that. I think a lot of the design factors about how we exactly structure `:unit` depend on whether we enforce a split of some sort.  
* EAO: Do we have further thoughts on unit?  
* RGN: I think this was a good exploration

## Default Attribute Definitions

[https://github.com/unicode-org/message-format-wg/pull/1098](https://github.com/unicode-org/message-format-wg/pull/1098)

*EAO: For consideration when we have more participation: could leave this out of what we’re trying to do at MFWG, given how little participation we’ve had recently.*

* EAO: The big question we ought to be answering first is the big meta-question of: given that I think we’re all agreed that almost all of the actual definitions aren’t actually attribute definitions, but are message metadata definitions or message group or message resources definitions, do we want to be doing this work here? Or given that the message resource work is not due to be happening under Unicode, should we be giving up the space of default attribute definitions to be done as part of work in the W3C i18n WG on message metadata fields?  
* MIH: My memory of that is rusty, I have to read the PR  
* EAO: Given that we have in our spec that the no-namespace markup and attributes are defined by us if by anyone, it means that if we want to allow for any non-namespaced expression attributes, we need to define them. If we are defining expression attributes and markup attributes, then we are aligned by saying that in most cases, these attributes should not be going on individual expressions within the message, but on some metadata block attached to the message, and therefore part of the resource file as a whole. It’s like part of this work is well within our scope, but part of it is either outside our scope if we say it is, or inside our scope if we say it is. The meta-question is, do we want to do any of this work here?  
* MIH: I’m tempted to say not here. All this kind of metadata would be really useful to be on all kinds of messages almost everywhere, including legacy MessageFormats, MessageFormat printf kind of things, all kinds of old stuff out there already. And because you cannot put all this metadata on the old format, you can’t put it on a printf(“%d”), I think it’s most flexible if it’s outside. So it would be beneficial to have something, but not necessarily in the MF2 spec. I think it’s beneficial to have things namespaced anyway if we put them in the message. The benefit of having them namespaced with things like i18n or l10n is that the compiler can exclude them all just based on the namespace. When you want to compile to reduce size, you want to remove all this metadata.  
* EAO: They’re already attributes – attributes are required not to have a runtime impact. So if you see that @-prefix, a minimizing compiler will drop it.  
* EAO: So I honestly think this or the CLDR TC is the best place to be defining the overall kind of set of metadata that is known, and can be applied to MF messages, or to any old format provided that you can attach a comment to it, and in the comment we can design a microsyntax.  
* MIH: What do you think about ITS, which is W3C I think? They’re already at version 2\. Kind of designed for XML, but that doesn’t mean it has to be limited to XML. Easy to say that this is how you do things in comments, or in other places. They cover a lot of the same stuff, it’s there, and it’s version 2 already.  
* EAO: I don’t think it covers all of the things we want.  
* MIH: I’m not saying it covers everything, but maybe an ITS 3 would be a good option.  
* EAO: Seems like a different project  
* MIH: But if you ask where it belongs, defining these attributes. Or if we put something in LDML, then I would say it should be ITS 2 plus something, or compatible with ITS 2\. There is some support for ITS 2 in some l10n tools. If we invent a completely parallel way to say stuff, those l10n tools would have to support it from scratch.  
* EAO: Looking now at the ITS spec to get an idea of what they support.   
* MIH: It’s definitely not everything.  
* EAO: How do I use this to define a description for a specific argument that can be given to a message, like `count`?  
* MIH: Since this was defined for HTML/XML, you put it on the element. If you convert a message to XLIFF, that parameter is going to be a placeholder in XLIFF, which is an XML thing and you can just attach an l10n node to it. That’s how it’s done in XML and I don’t know if it’s right…  
* EAO: \[missed\]  
* MIH: That’s what I was saying, take ITS 2 and this is how to use it outside of the XML space. THis is how you annotate stuff in a comment in code, or whatever. Which is not documented anyway – I don’t think there’s a way to do that with ITS 2\. There are two things, one is how we attach that info, and one is what are the things you can attach.  
* EAO: I think the “what can you attach” is something we can work on, and should work on, which is why I raised this PR. What I want to work on is a Javadoc or JSDoc syntax for messages like this.  
* MIH: What you said makes sense, since a lot of this stuff should apply to groups of messages, or a whole file.   
* EAO: It can go there, but if we come up with the language of “this key means this thing” and so on, then we can say that this key can apply to just one message or this key can apply to multiple messages. I know we’ve had a whole discussion about this, but maximumLength is something that might just apply to one message. So are we saying that we do want to work on this at the meta-level here, or do we want somebody else to be fixing it? I don’t know of anybody better for it than us.  
* MIH: It feels like a different project  
* EAO: Slightly different from the Unicode MessageFormat syntax spec, which we’ve been working on. But we still are the MF WG.  
* MIH: A lot of this stuff isn’t about message formatting, really. It’s about l10n. If you take a typical resource file, a big percentage of messages don’t have parameters, don’t go through MF at all, they’re static messages. This stuff applies to those. So that’s not MessageFormat, it’s l10n tags.  
* EAO: I think on a technicality, it still is. I think again, in order to – I think we need alignment within ourselves about whether we’re doing this work or not. Shane, Richard, do you have any thoughts on this at all?  
* RGN: I think it falls on this group by default. I’d be open to having it taken over by someone else.   
* EAO: Who else?  
* RGN: That is the question.  
* EAO: I think it’s a little beyond the purview of what the W3C i18n WG usually does, because it’s about communicating with translators. I find that that has been a driving goal for our work.  
* RGN: It’s an interesting point. Does that mean that venue-shopping is in order, or that the scope can be expanded? Does W3C have a format chartering type approach, the way some other standards bodies do?  
* EAO: Yes, and I think I’m going to need to figure out how that goes in order to get the message resource work formally chartered. The remit of that work might include defining the keys and values that are applicable for metadata like this. Maybe what I’m asking is, should we be incubating this work here? We clearly have opinions. For example, maximumLength.  
* MIH: I think incubating without saying “this is where you glue it”, that might be a good starting point. I think it would be very useful to be able to take it out of MF2 at any time, so that other formats can adopt it and hopefully use and increase adoption. “Hey, you can use it on Android XML and Java properties, with your gettext old stuff and it still works.”  
* EAO: What we might want to start with is not working on the syntax of this, but working on “these are the keys and these are the possible values for that”, and leave it as a question for later and possibly elsewhere how we define the syntax for connecting these.  
* MIH: That’s how I would go about it.  
* EAO: I think that sounds good. I can work on the PR to make it more clearly show that it’s about incubating this work, possibly for standardization here, possibly elsewhere.

## Back to Unit and Datetime Formatting

* SFC: I like what you discussed in the notes. The pound vs. cup of flour thing is interesting to raise. It seems like this is something where the value would also be included in the message or something, because you can’t just convert one to the other. It’s not something where conversion happens. I think it would be helpful to have some examples of messages where you want to have weight and volume. Weight to volume is kind of a common thing. If there are some examples of actual messages that seem like they would be plausible, I think it would be helpful to add a little more context there. The main use case is allowing the translator to pick the unit and having the input be automatically converted, and that can only happen if the dimension is the same. Given that the primary objective is to allow the data slicing, if you were going to name “cooking” as the main category, then that’s almost more useful because I don’t have to ship all these weird volume units. That’s the main objective here, to make the data smaller.   
* EAO: One relevant design question is that if we were to allow in the spec leaving out the unit type definition entirely from the syntax and rely only on runtime, while possibly through linting and other tools encouraging devs to give more info so the translators have a better time dealing with a unit expression, would this spec language create a cost for all ICU4X users? Or only for messages in ICU4X that happen to not define any unit type or usage or anything?  
* SFC: Trying to understand the question  
* MIH: So if I try to format a unit thing without saying what it is, it's going to bring with it a lot of data. The linter will yell at me and say “this means a lot of data loading at runtime.” But if as a user I react to that lint and say “this is weather stuff”, I’m not going to incur any price, right? If someone else doesn’t specify anything, it doesn’t affect me.  
* SFC: I think having concrete examples would help immensely. My best attempt at answering this in the abstract is that the way the unit function is designed, which allows a unit function to be specified as input, means we have to be prepared for the case of loading arbitrary units, which is not great, but it means – I’m not speaking on behalf of ICU4X TC, I’m speaking on behalf of Shane, I think it’s not a major – wouldn’t break things. I think it’s not a great design for the committee to allow syntax that we know is not good and want to have a lint to discourage, I think that’s not a great design, but I don’t think it’s infeasible from the ICU4X perspective. I just think that why are you designing something that relies on a lint to have good behavior?  
* EAO: The question I was trying to ask is: if we imagine two users of ICU4X, User A is a well-behaved dev who will say that this unit that I’m now formatting in this message is going to be a person height of some sort, or a length unit of some sort; then we have another user that’s using a unit and will give only runtime information about it. The second dev wants to only give the info at runtime about what unit is being formatted. If ICU4X were to allow for the second type of behavior to happen, would it create a cost on the experience of the first dev?  
* SFC: I think it’s possible to design it in ICU4X so that the second case doesn’t degrade the first case, but that’s not an official statement.  
* EAO: If that is the case, then our predilection would be to allow for bad behavior while recommending against it.  
* MIH: Shane used words like “incorrect behavior” or “wrong”, I prefer to talk in concrete cases; the trouble is that when you declare something non-draft and final, and it’s going to be there for 20 years or more, you can’t say you imagine all the concrete cases. You have to be flexible for the future. That’s why I’m more reluctant to forbid stuff. You do things that we think are wrong, you pay a price, but the standard won’t prevent you from doing it.  
* SFC: I agree up until the end, which is that I would tend toward forbidding more things than allowing more things. Once you have evidence that people will want to do things, you can make it more lax –  
* MIH: You can’t change it later  
* SFC: You can change an error into a non-error  
* MIH: No…  
* SFC: So you want to allow a behavior that you haven’t tested to see if it’s a valid behavior? This is why datetime skeletons have caused us so much pain, because we said just allow people to do what they want, and then it turns out that people are doing all kinds of things with classic skeletons.  
* EAO: Let’s try and return to unit formatting at a next meeting. PRs on the spec for this one are quite welcome as ways to propose advancement for different parts of this. I’m going to at least need to look more specifically at what we have written for this. My sense is that unit formatting – I see more use cases for allowing runtime-only definitions… if allowing it does not degrade the experience for situations where more info about the unit is given earlier. That’s also informative to translators who are working with messages. I’m also open to first starting with the thing as an error and later changing it to allowing it.

Next meetings: 2025-12-15, 2026-01-05, 2026-02-02 (with an option on some more in January, if desired)
