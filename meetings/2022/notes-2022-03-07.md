### March 7, meeting Attendees

- Romulo Cintra (RCA) Igalia

- David Filip - XLIFF TC, Huawei (DAF)

- Mihai Nita - Google (MIH)

- Staś Małolepszy - Google (STA)

- Mihai Nita - Google (MIH)

- Batjaa Batbold - Amazon (BAT)

- Eemeli Aro - Mozilla (EAO)

- Zibi Braniecki - Mozilla (ZBI)



**## MessageFormat Working Group Contacts:** 

- [Mailing list]([https://groups.google.com/a/chromium.org/forum/#!forum/message-format-wg](https://groups.google.com/a/chromium.org/forum/#!forum/message-format-wg))

**## Next Meeting **



**### Moderator : Rômulo Cintra** 

### **Agenda** 

his weekly meeting will focus on display/markup elements, which have been discussed previously in [#26](https://github.com/unicode-org/message-format-wg/issues/26) and [#186](https://github.com/unicode-org/message-format-wg/discussions/186). They are rather variably supported in our current spec proposals:



* Eemeli: [syntax](https://github.com/unicode-org/message-format-wg/blob/ez-spec/spec-syntax.md#display-and-markup-elements) / [data model](https://github.com/unicode-org/message-format-wg/blob/ez-spec/spec-data-model.md#element) / [resolution](https://github.com/unicode-org/message-format-wg/blob/ez-spec/spec-formatting.md#element) / [error handling](https://github.com/unicode-org/message-format-wg/blob/ez-spec/spec-formatting.md#element-1)
* Staś: Not directly supported.
* Mihai: [open/close/standalone placeholders](https://docs.google.com/document/d/1kqD0gy5x1mfiF2PAegjcNCAc98snTAqtbxccxfLcpNo/edit#heading=h.93qjwqomt7pu)

Questions that may be answered by this discussion:



1. Should display/markup elements be supported by the spec?
2. Should standalone elements be supported?
3. Should start/end pairs of elements be supported?
4. Should other connected sets of elements be supported? For example, a start/middle/end set of elements.
5. Should elements be separate from placeholders/formatting functions?
6. Should elements be used to mark up messages for formatting? For example, to indicate that a span should be styled bold.
7. Should elements be used to mark up messages for localisers? For example, to indicate that a span should not be translated.
8. Should some elements be supported by default?

Comments: 

I believe that lot of formatting can be covered implicitly by formatters' behavior, but I guess there will always be important use cases where inline markup cannot be omitted, so the implicit and explicit formatting should be aware of each other in the standard. Also it's important that the inline markup data model is mappable onto XLIFF inline model. It's okay if inline markup doesn't use well formed equivalents, linear only data model is okay and mappable onto a model where also well formed markup exists..

### How should start/end pairs of elements be matched with each other?

We have to find a counter-argument for the use cases that can support different ways of matching different from HTML or XML. Reordering , Opening and Closing tags or neste of don’t need to close how they should work. 



* No conclusion, we should revisit this later on and try to get more use cases

### Should elements be separate from placeholders/formatting functions?

 



* 

### Should elements be used to mark up messages for localisers? For example, to indicate that a span should not be translated. 



* No conclusion, we need way to communicate to localisers, we should identify how to do it

### Should some elements be supported by default, i.e. included in something like a common registry?

CHAT:

Mihai ⦅U⦆ Niță7:01 PM

RTF:

...\b bold \i bold and italic \b0 italic only \i0 ...

Eemeli Aro7:01 PM

Talking now nominally about mathcing tags by id vs name, but actually about end tag attributes.

Mihai ⦅U⦆ Niță7:10 PM

[https://cloud.google.com/text-to-speech/docs/ssml](https://cloud.google.com/text-to-speech/docs/ssml)

Zibi Braniecki7:12 PM

"say-as" - looks like a perfect example

**_Meeting transcript_**

MIHAI: HTML is cheaint in a way. If you think about the CSS before and after, right, the after thing, it's kind of a cheating way to add content to the close tag.

Which without CSS, you would really want to attach those things, but it kind of cheated to solve that problem.

It's not it cheating, I think it's an elegant solution.

EAO: How about I make a recommendation that we return to this question when somebody can come up with an example, of a message that would really, really benefit or need attributes on and tag. Because at the momentit is hard to argue about this because that's entirely in the theoretical.

DAF: But you know, it is still assuming that you are importing stuff from something like, XML, where end tag is something special, something not fully kind of if not the full data model, but just in RTF like, the mark-up is not something up or Changing State. Or also thinking about about bi-directional algorithm. This is another thing that behaves this way, you know, like if you if you if you have an indication of directionality change, which is orphaned then it goes either to the store or to the end. So I mean, there are syntaxes that don't assume that closing tag second-order citizen.

EAO: In this case, do you think I wouldn't? Really actually make sense in in a message for my message to represent those tags, even if they are start and end tags with stand-alones.

DAF: No, no.I don't think so. Like, stand alone is a different use case, I think that was kind of our consensus. We have three different things, stand alone, start and end.

The difference between Standalone the start and end even if it's orphaned, it delimits some sort of span. Right? A standalone doesn't. Stand alone, as you know, is an atomic thing, like, whatever happens, happens inside this standalone thing. It has no no area.

EAO: Yeah, okay. Again wrapping up what we've been talking about so far. I think we need to raise the issue that we do need an example of, if you say, "In RTF there is a situation that an end tag really needs to have attributes". Then let's consider and return to this question. Once we have that example, to consider and to play with. And for now, move on with some of the other topics.

Or we could we could, return back to the matching by ID or name which I don't think this is actually touching, Because even if we have all of these things that were talking about on the end tag, I think we can still, I'm still missing, at least for myself the argument:

Why isn't the name sufficient?

What is the situation where the name of a tag is not sufficient to match that?

You know, this is the start of it, ff the SML foo thing, this is the end of the SML foo thing or again the use cases in in different situations.

And for instance HTML or XML, where it's way more common to have possibly like nested or improperly nested tags, that use the same name but need to match with each other. If you guys see what I mean, or understand?

MIH: I think we shouldn't look for HTML or XML specific examples here.

EAO: That's what I'm saying. It's clear that in XML and HTML it all works by matching by name. And the argument here for needing an id in addition for a name or would realy benefit from of a real-world example.

MIH: We'll look for example.

ZBI: I'm also working toward to see what is impossible with matching by name, and what I think is impossible with matching by tag name is from HTML perspective, improper and nesting.

So, I don't know what the proper English name is, cross nested were like "&lt;b>&lt;b>&lt;/b>&lt;/b>" where the first closing is related to the first opening.

MIH: So do you see MIH message between my messages in there, I think that's roughly what you're talking about, but just expressed in RTF.

Because I think there, I would say that the b and the ... are being matched. And something like this in HTML would work fine.

MIH: In HTML what ZBI described, it's really, there's no real incorrect nesting because it's tag based.

ZBI: Like a tree, it's a forced tree. So if we want to allow structures that are not proper trees, which I see two scenarios.

One is easier to reason about scenario, which is that we want to be able to parse a message in the process of being constructed.

That's definitely important for any parser. That will be provided to tooling. It has to be able to reason about a message as a person is typing. And the person may not have finished it and they may be in the process of typing, mistyping it and they want to correct it.We should be able to reason about it, even if an error, it should be on a different level that you should have proper message. We're not going to parse it. Or we should parse it and then say, you're you're trying to embed it in HTML and those tags are not going to do properly closed.

The second scenario is much more open-ended, which is that I think, to MIH s point point where we're not only going to be handling HTML and other elements bindings may not have the same constraints as HTML has.

So if there is no strong need to limit it to HTML like tree structures, then I don't see a huge value in shaping it to limit the same way.

EAO: Yeah.

Definitely one question that I should have asked that what was discussed briefly before you joined is that I believe everyone in the working group, currently participating in discussion agrees that we should not require start and end tags to be proper but allow at least for parsing and handling at the data model level for orphaned start the orphaned end tags.

So that for instance, in editing use case among others can be, supported. Another point that I think, is implicit that I want to make explicit here, is that I do believe that we are considering that matching for instance, by name is simpler than matching by ID in the sense that it does not require adding that extra ID field into the whole structure and that therefore matching by name is a simpler solution and matching by ID is a more complex solution. And therefore I think requires more more explanation for why it is needed.

MIH: I'm almost empty to say wine to ask. Why not both. In that hey, you're the developer, you know, better how your tags work.

Right? If it is important that this closes this other span, be my guest.

EAO: I think here as when we were talking about the the end tag attributes. If there is a use case that can be shown that would benefit, don't need this. I'd be willing to very much go for something like this, much more than requiring ID, but I think an example of at least one case. I think I have a case, why this is.

ZBI: I think I have a case. I was thinking about when we recently discussed non properly nested structures and think the one example we discussed very recently was format with, mark, formatting to parts of message.

Where it's not really parts.

And and from there, my example is, when you are informing, formatting information for the for the voice interface.

You may want to mark some subset of the message, as emphasis or faster or louder, whatever you want to say it and then some other part. As stressed or relaxed and they can overlap.

And if you don't allow for overlapping, then you basically have to say is "&lt;emphasis>&lt;emphasis and relax>&lt;/emphasis>&lt;/emphasis and relax>", which seems to me like it's cumbersome.

What I'm trying to say is that, annotation of a message formatting does not necessarily have to cater to trees.

EAO: And there, you're thinking that there's at these annotations would end up using the same tag name, effectively.

Or would they be using different tag names?

ZBI: Hmm, I don't know but if you want me to draw a strawman, then the strawman would be

tag name is emphasis and the value of the tag is what kind of emphasis and then can be two emphasis that are not overlapping perfectly or intonation or voice intonation.

Right?

It's a strong man.

I have not found about this to people.

It's just an example there.

I think we can evaluate whether it's worth considering.

EAO: I suggest we we kind of put this a little bit like we were talking about end tag attributes

that this is something for which that we ought to continue considering.

But that really good examples and actual, like, current world use cases, would be really good for this.

STA: Sorry, just one more question on this topic.

Would it be viable to support for some of those ... to work as a stack rather than a well-formed tree.

So in the example the ZBII gave like you could pop off pop the closing emphasis off the stack at some point and this way we wouldn't need to IDs I guess.

ZBI: Stash look at the example that MIH gave. Maybe we will want to go into different route and then force difference in tags in this case. But a tag &lt;say-as> is a generic tag, that has a value.

So there can be two &lt;say-as> overlapping with different value of &lt;say-as>, but a stack doesn't work.

EAO: But does that actually apply for SSML?

Because what I'm seeing in the docs in the example, there is that there's a closing tag,

that's just &lt;say-as>

...

EAO: I think this is actually pointing at a slightly different question, which is that so far, we've been talking about start and end tags with the implicit understanding that.

The, these are like, effectively enforcing ordering after tags, but we can.

also consider also ordering of practically any pieces of a message as requiring to be before another piece or after another piece, is this something that we want to allow for is their use case for that and should be considered this separately from start an end tag matching.

MIH: When you see any other piece, do you mean including literal text.

EAO: I'm saying that, this is a thing that can be considered.

I'm asking whether we should consider it.

MIH: I don't know.

I was asking.

What what is the thing we should consider? Prevent reordering of everything, including literals?

What should we consider or not?

I'm not sure.

What is the question before answering it

EAO: So what I'm trying to express is that, currently the only thing is so far that I'm aware of us in MF2 spec data model work, or wherever considering where order of things matter is or it should be enforced this way, is that if we have elements with start and end tag, the end should be after the start.

This is one specific tradition of ordering of parts within a message.

I'm saying that it is possible for us to consider means by which it would be possible for any placeholder, for example, we declared ... after that other placeholder or something like this.

Is this something for which there is a real world use case that we ought to consider?

Or should we not?

MIH: Realistically, I I don't know if it's needed for what we do here.

four in my mind that the can reorder, I told you to prevent things like printf ...., prevent you ordering for instructions like this because you go to XLIFF from something and you don't know how crappy that something is.

RCA :I have two questions and just want to clarify one thing regarding this.

Should we have a consensus regarding matching by name or by id? ...

I just want to mention that we are looking through HTML and through different markups. But we can maybe limiting our own decision assumptions order to not complicate too much our needs if you don't have use cases, that could support that.

I know that look into the future it's okay, but as far as I understood, the actual behavior can maybe replicate from HTML with some limitations, it fits perfectly for our needs.

EAO: Yes, it could.

But effectively to, to conclude this discussion.

We need to at least see if we can find an example, a counterexample for situation that needs something more than what HTML and XML go with.

It may be that we don't find one or that we find one and then we end up discussing for the name versus ID thing.

Specifically, I think what we would be considering is not requiring ID, but allowing for ID in addition to my name.

MIH Do you have thoughts on that yourself?

I'm referring to the incoming message that MIH posted.

MIH: Level bold image mode.

Yeah.

I know, for instance that it's you can do that for instances today with XLIFF but things as somebody who had my hands in the validation for a copy were trying to validate stuff like that.

It's nice and easy to validate things like this.

If all tags are tagged, do not reorder.

It can be ordered false.

The trouble is when we start having mixtures, right?

Imagine taking the `&lt;b> ... &lt;img> ... &lt;/b`, but now you have some italics, and some span and the line break, and those are not tag

that can reorder?

I mean those, you can reorder, but these three you can't.

So now all of a sudden you get all kind of crappy thing.

So if I have a line break that it outside, am I allowed to put it inside the bolt?

Because that line break was tagged with can reorder, right?

So it becomes very tricky to validate once you have tags with mixed all together.

It's either you cannot reorder anything or you kind of can reorder everything except for open close, which you want to order.

But yeah, I know it's almost bike-sheding at this point, thing slike these are probably so rare that you can just say.

It's fine, and if it happens it's bug and we'll fix it.

EAO: How about this for an issue that might want further consideration later and move on?

Okay, for a next one.

How about the question of, "Should elements be used to mark up messages for localizers"?

For example, to indicate that a span should not be translated.

And here we had in the in the responses.

We've got like three people saying, no. Three people saying yes and one person saying not sure.

So I figure that this is opinions are divided.

MIH: Oh, yeah, I would say that.

Maybe some of the things that is tripping people is, if we need to have a way to tag text for translators to say, this is not for translation.

And I think if that would be the question, I think everybody would say, yes, you need a way to tell translators done translate this thing.

I think where people are split is, if this is the right mechanism to use it, right?

And yeah, I was in the in the camp saying, no, because it's not a UI thing. The fact that this is translatable or not, is not a formatting attributes of the text in the broad sense, right?

For instance, in the in the EM proposal it's not like this.

This is the proposal for read only stuff in the year model, or you can have a function that is called read-only or something like that.

Right?

But a chunk of read-only stuff, it's a standalone placeholder if anything, there's no beginning and end.

EAO: Does this mean if you have any text that is escaped in this way would therefore marked as non translateable? Because that would be challening to consider, because would there be a different escape method that you wold be proposing?

STA: ...

DAF: I'm against using non.... I belive non translatable just a property of things and it should displayed to the translator.

There are different strategies for non translateable for XLIFF the most common is not to extract or hide it in standalone or mark non translate as non translateable and all three are useful in different contexts. (gave example for each use case).

MIH: The first answer was though, about the fact that you want to show you to the translators.

Yes, the the no trans text, with the text inside would be sure to the translate things.

But I'm looking at what XLIFF is saying and found this quote: ....

The Do Not extract is not really working because that's only message level.

Right?

It's like this whole message, don't know, but we are talking, you have a message, but I just need a message, don't translate.

DAF: I just wanted to explain that.

There are three different strategies that make sense in different scenarios.

Even, even even to do not extract even the Do Not extract sometimes if possible and still it doesn't make sense.

If you have, for examples, like analyzing a French poem in English text, you know, like then the French poem will be non translatable.

You have to they have to have it there or you're screwed then.

Another case where you need that is, if you are translating something about GUI or or about Hardware that that has, that is basically UI element, that cannot be changed, some, some inscriptions on, you know, on on Hardware, you have to keep it or, you know, or basically you're referring to something that you are is out of your control. But the translator needs to know what it is.

I think it's similar to the use case that we click nextm, next is in operating system say you cannot do anything with that.

You're just referencing.

EAO: so, My thinking on on elements has been done, So, when looking at what XLIFF is for instance doing, XLIFF has separately annotations as two separate sort of sets of tags for communicating clearly to different audiences about what is happening here with a message.

And we're talking of having at least one set of things that have a start and an end basically, describing something of their contents in MF2.

And I think a valid question here is that, the reasons for why XLIFF ends up with having these two completely different sets of things are valid but can we end up representing both of those with with one set of things. Are there features that we're doing this?

DAF: We might decide that we don't need the annotation capability, we leave it to XLIFF, we deal with just with .... It will be easier.

EAO: But then, as I'm been thinking of one, like here, I'm talking display or mark up elements, is that they are in general describing things about the structure. So, that at the level of the, for instance data model, it is not necessarily relevant, whether when you just purely parse syntax to be a data model, whether an element is meant for formatting purposes or to provide an annotation for localizers.

So what I think would be beneficial here is also, we clearly need to be able to communicate some things to a localizer about a message. The things I'm aware of that we need to communicate, one would be that here is a comment or something describing this placeholder or thing saying something about it.

Another part is that we may need to communicate to to a localizer here this part of this message, even though it looks like you could translate it.

Don't, just leave it as it is.

DAF: ... What you just described, sounds like an extended use case. (gave examples)

XLIFF is a notes mechanism that is on the structural and this is specifically saying things about the structure.

Annotation mechanism would be helpful to describe notes in more detail.

EAO: The way I thought about this is being able to attache comments to any placeholder. Thereby if you have a specific word in a message you need to attach a annotation saying "this has to match this" then that's possible using something very much like what MIH posted earlier.

1 question I wanted to ask, do we have other things that we can imaging needing to communicate to localizers? And secondly, the non translateability of certain bounds of content?

MIH: Tons of things before I jump to that. What we tell translators.

In my experience, working on a copy and inside localization stuff. It is very hard to work with placeholders and and annotations the mkdown? in XLIFF.

I don't think I've seen a tool that handles this seamlessly.

They tend to represent markdown as placeholders in the UI and they are not the same animals and they're not the same animals in that as a translator I have to avoid the placeholder

and have to move them around and and not touch them. They are black boxes, but they get in the way, while the markers MRK are not.

I shouldn't even see them, if I delete them by mistake, who cares.

Because normally those are tags for translators. You don't even need them at runtime, right? So if I give this to to the Javascript file frontend, who cares that that is It was localizable or not, right?

So, That's why my mind the UI elements and the "Do Not translate" problems are kind of orthogonal. UI elements are propagated at runtime you use them to render things differently.

Markdown, The not translate, you can drop it, Who cares. If you want me to ... me now.

Otherwise, I'm going to say what else you need for translators.

You need a lot of things.

Yes, it's "do not translate".

The other one is, "this is glossary term" like, look at the glossary term we establish for our translator.

Links to screenshots, restriction on what you can do.

I want these translate this but try to stay below, 80 characters.

DAF: Actually 2.1 has full support for this, so all of the 19 categories can be around roundtrip.

MIH: All those things. If you look at the rules, they're all things you want to tell translotors.

Basically there're tons of things you want to tell the translators.

EAO: Okay, to sum up.

It sounds like there's a general category of metadata that needs to be communicated to possibly to translators. In EZ, I added a link to the incoming messages, showing how semantic comments in the EZ spec handle this.

So, we have "no translate" and "comments" which may be semantic comments, which may bring in ITS tags or others to to specifically communicate specific things.

Do we have other things? Anything else that we may need to communicate to a localized or translator?

MIH: It's a bit of a trick question. The whole semantic stuff is, it's an unbounded number of semantic tags. So what can it be? Whatever I can come up in 5 years you put them in semantics and that's it.

ZBI: But we could establish ... and know  ...

Any quality tool shold know wheter a part was touched.

EAO: So, are we saying that we should encode a specific option or an attribute for this, to be always understood to mean "this" if it's included?

DAF: You could actually use, the ITS tags, it is basically a metadata standard and it is designed for inclusion in different syntaxes.

So, if you use these categories, then it should be mappable and round trippable in XLIFF. So I think it's a good idea to stick to it, for the known stuff.

EAO: But are you saying that we should encode a requirement to use ITS tags, whenever one is suitabl and you need, or attributes or options.

DAF: They are attributes. You can define your tags and one set of possible attributes is ITS2, they tested it, you you know that they work.

EAO: But the question that we got here is that, ITS2 to has a whole bunch of possible things in it.

And one thing we could do is mandate use ITS2 whenever you have got anything that could be in there.

Other approach that we could think is, for instance, what HTML has done where specifically the "no translate" attribute has been picked up and it is a part of the HTML standard now.

And it matches the ITS2 definition, pretty much. This is a specific thing that we agree, should be applicable to messages or at least parts of messages somehow.

So, I'm asking should be mandated or rolled it into the spec, like in HTML.

DAF: Because it's a metadata standard you have different possibilities on how to adopt it. For most of the categories you can express it as local markup or you write global rules.

And say this kind of things is it always untranslatable.

Like what ou said like HTML adopted, translate was first defined in ITS1 and between ITS1 and ITS2, HTML adopted "translate" as a native attribute.

It always was in XLIFF.

If so, you know, like if you already have the category in your format, then you basically just create some rules.

How are you map it, how it behaves.

EAO: That's the question I'm trying to ask.

Should we adopt it as a native, MF2 attribute or option.

DAF: I think, translate should be handled as a Boolean so that it's roundtrippable, and you can have it native and say this is metadata category from ITS2 and then it's clear to everyone.

EAO: I'd like to hear from others here.

Whether we should do this. Because currently, we have absolutely nothing that we are doing, where we are saying that this is a specific attribute or an option that has "this" behavior in MF2.

But is this something for which we should do that?

MIH: EM spec there's a section about non translateable entities.

...

ZBI: My preference would be if it was a semantic comment over any part.

...

STA: What are people thoughts on using aliases or macros assuming they can include text content. Using macros sort of span marking...

ZBI: The way I think of the role of semantic annotation of parts, of meta information of parts, readonly fits into this perfectly. My mental model is, if we handle readonly, then there will other similar meta information that we want to encode. MIH gave some examples, length example. The communication here is between tools, really. And authors. Human can read this and reason about this.

But we want tools really understand this.

...

(STAS & ZBII discussion)

MIH: I think the last few minute discussion is a segway to "Should elements be separate from placeholder/formatting functions". My argument to put those things in placeholders, was that if you look at them, let's assume UI elements are different things then placeholders. They need something saying beginning, end or standalone, you'll need something like a name, same way placeholders, you need a way to say it's a function because you want to support different formats. And you have extra tags, if so, what's the difference between a placeholder?

EAO: Before we get to that, I think a question that's still open is that, do we have a specific need to be able to communicate to localizers that information about a sequence of pattern elements? Rather than, communicating "translate no" about each one of them individually.

So, do we need a way of saying that from here until the end of whatever everything applies or can we say it applies to this, and this, and this.

Does it make sense?

ZBI: Yeah, for me. It's a similar question to the overlapping part.

Is it okay to solve it, by saying that you will mark this and then mark this. With the same thing. Or do we actually benefit from semantically informing that this is one.

And there's a cost. If we say like no, you have to chunk it into three sections with the same notation or same.

Yeah, I think there is a cost but I don't have a great example. And what I'm a little bit worried about is that because of the prior systems being fairly limited, and if anything following SSML.

By nature, we have a self-fulfilling prophecy.

MIH: Why do you think this is connected to the idea that you have placeholders separate or not.

...

EAO: I think we are not going to reach a definite conclusion on the on the information to localizers here, but we should mark it as I think that we do need a way of communicating to localizers it may be possible for us to communicate this information by assigning individually to pattern elements, but it may also be that we can identify and convince ourselves that we need to be able to expand whole sequence with one piece of information.

And then I think we get to know start talking about what MIH has been alluding to in his previous two comments, which is overall do we want to have placeholders that may have a stop and an end connection to them. Or do we possibly want something like structural display elements to be a separate thing from placeholders. And MIH do you have thought on this? I'll be happy to continue after you.

MIH: Tagging individual elements will still allow translators mess up the order of things.

EAO: I don't think I've really because we haven't had this discussion elements before.

We haven't had a chance to to express a lot of my thinking or how elements or to work has formed itself while I've been working on the suggestion for how are we going to build the Intel that message format, JavaScript API, because fundamentally that needs to be a base.

Or which someone can take, he didn't sort of formatted to parts of formatted to a structure output or something that we build with, with message format to and build either a DOM localization system on top of it or something, for instance, like a react localization on top of it.

So something like a bold tag.

For instance, end up needing to be able to go to Entirely different directions from from where it's coming.

From a reactive element, Dom element are fundamentally, you build them in different ways. They're different libraries that need to be to make that work.

So within Intl.MessageFormat, what we need to do is figure out a way of making it make good sense for someone writing a MF2 to DOM localization system and a MF2 React localization system to end up using Intl.MessageFormat as the actual thing doing the message format part of it. And this has informed, at least my own thinking quite a bit in that either. Both of these, the React localization system and DOM localization system it's not enough for them to take bold open tag contents that go in it and bold close tag and separately process these. They need to be able to in the end take the &lt;bold> tag and here is the body of and do something with the body as well as the options given at least to the start tag.

If we are, my thinking there are, two different ways that this can go one, is that, it is possible for me to somehow define a custom formatter, for something like a bold tag in in the MF2 as a custom formatting function, but then that bold tag needs to take as input that the bold tag name, the options or arguments in the tag and the whole sequence which may itself, contain other the tags. And so on. The alternative for these structural elements, you can't even do that because custom formatting functions is allowed to get at anything other than the the arguments and options passed directly to it. And instead, what we are producing on the outside for formatting functions, yes, we are determining the value of it, but elements, end up determining no value but the structure of how things work as its output, and this to me is telling stories that really elements are fundamentally different than placeholders.

And this is one reason why they are in the EZ spec syntax entirely different animals.

STA: So, if I understand correctly. A flat sequence of parts in the data model, let's call it raw data model. Would produce ... I think from my prev convo, I understood that you're advocating for separate syntax which is really just consequence of a separate data structure. So you can to the processing as part of the resolution part.I think the alternative which I have been trying to pursue an advocate for is that we we still yield a flat sequence of parts. And whatever post processing is required is done one level higher by the user code.

So here I imagine a specifically for Intl.MessageFormat, I imagine the API can be basic enough to be able, to be used by userland libraries to do what you're describing, but the API itself. Native API would not enforce this post processing. Is this the dichotomy that we're talking about really? Do I get this, right?

EAO: Yeah, I believe that is one aspect of it.

Zibi & MIH probably have more to say on this.

ZBI: I'm gonna repeat my 2 talking points.

1) I belive that fundamentally what we're considering elements & placeholders have different needs & limitations. And collapsing them into the same structure requries as to create a very open ended entity in the data model. That has a set of attr and shapes that cators to placeholders, formatting placeholders. It's union of a shape needed by placeholder and formatting elements. Ofc, we can make it generic. But in any scenario in which we can reason about what is needed for elements & placeholders, I believe the union is not overlapping. Which indicates to me it should be 2 different things.

2) If we're to be a little bit strict about what arguments and shape the elements take, then we make it fundamentally easier for tools to reason about. Even if we do what STA is saying, that we let another level completely resolve the structure or tree. I believe that our success of this delicate binding of message format into some UI bindings and the MF is what the CAT tools will be dealing with and QA tools depends on what API of the declerative parts we provide to those tools to reason about.

So an element with open and close, is very easy for a CAT tools to sat there's no close to this open. Black Box placeholder called element with attributes that are maybe somewhere designed, described in some registry require a CAT tool to look into registry, retrieve the API and reason about what attributes should be there and what their their meaning.

And I think it's very quickly is going to fall apart and tooling is just not going to bother just going to treat it as a black box.

That's my concern.

MIH: It's kind of ... you say touch is what you started by saying, like they are fundamentally different and they have different needs.

I would like to hear what they are because I don't see the difference. I just don't. The one that you just mentioned that, the tool would have to look in the registry.

Not in the EM model. In the EM model, the open close standalone tags are part of the placeholder itself are in the data model. They are not in the registered, they're independent of anything.

React vs building a DOM, what I've in mind Gmail in the same I'd like to produce UI Gmail browser based which is HTML, I'd like Android spannable thing, which is a different concept, it's a tree.

I'm also thinking what if I need to create ANSII escape. I want to create console & UI app, can I do that? These are the things I try to follow. None of them forces me to see placeholders as different then the UI elements. Basically, I don't agree with what Zibi said, that they're fundamentally different.

ZBI: Right, and I think it's a reasonable thing to say.

I think it's like, you know, depending on how you look you may see it as a different I can dive deeper into its I'm not sure if this is most useful time.

I think we can stop at establishing that I think they are different and you're questioning whether they are.

STA: I might offer a prespective that might be useful. In my proposal I thought we can get away using regular functions and regular placeholders. But then I was convinced by MIH that open/close/standalone is really useful. I think with the provision that we have open/close/standalone it might be that regular placeholders are enough because they're not regular anymore. They've open/close/standalone, that's exactly the diference that ZBI is talking about and the fact that MIH says there's a difference, well there isn't because in MIH's model it's a placeholder with open/close/standalone. That's my understanding. Another comment, ZBI you said that XML is very generic but in fact a proper XML should have a doc associated with it.

I'm sure there'll tools that will just MF without registries. But I think we should be able to expect to tooling proper toolings to take full advantage of registry. Where we could define much more detail about placeholders. But thanks to MIH open/close/standalone provision, I think we can also support non-registry use case. Plus runtime, it's gonna use it a lot.

EAO: Before I ask a question from MIH and pass onto ZBI, I would really like to hear from the other four on this call who are not authors of these proposals.

Because clearly we have deep opinions about how these things ought to go and we found solutions that reads consider to be good for the purposes that we think are but we'd like to hear from others.

I think we need to hear from others to get a bit more of a feedback or how this is gone.

But MIH, I think one thing that particularly bothers me about having placeholders that allow for being sort of possibly just placeholders that formatting functions. ... in my head mixing two entirely different concepts.

And I think specific question I have for you is, in the EM model, you have a placeholder that is a start of something, is that placeholder also able to have an argument in addition to options pass to it?

MIH: What do you mean?

EAO: Can I have, can I have a number variable foo and formatting function and also have it be a start of something?

MIH/STA: Yeah

EAO: That's a bit weird then.

ZBI: My position is not stronly held that an element necessarry as a separate element. I think you're fairly sucessfuly by weakening my position but I think it's more than just open /close. MIH & STA listed 4 items but I think there're more and I think about it and make a stronger case if you think it's useful. To list them:

- open, close Standalone is one example that I'm not confident that there's value for placeholders. except when they're elements

- the other is elements necessarily cater into some UI structures. So the content of an element. May be a strong structure that goes further down, while the content of a placeholder, placeholder doesn't have a content in my mind, at least. To rephrase: It has a Content within a place called there but not Then open and close of a placeholder that the space between of open and closed, only matters when it's an element in my mind.

- third is attribute, UI formatting elements have attributes that are localizeable and some of them may be a custom elements that we have to whitelist which of attributes are localizable

- fourth, that i haven't fully understand in my mind is, eventually the outcome of a formatting element is to be overlayed by some UI structure that exists

...

EAO: Do we have comments from others?

(goes into discussion to understand why everyone is not communicating)

(people are still actively listening to understand — missing experience and full understanding to comment)

MIH: Let's look at what I think is a placeholder & UI element. Both would have a name for the placeholder, count for number, bold, italic etc a function that can be a custom function because I don't only want HTML. You have a bunch of attributes fractional number, rounding up vs class, id and so on. They've the same element a name, and options. The core different from the surface is one has open/close and the other one doesn't, in the EZ model. In the EM model it's unified, it's one thing with open/close/standalone. But if we agree that we all need those things I've enumarated then technically I can say, they're placeholders, placeholders that have standalone/open/close flag we call them UI elements and they're intended to be used with other stuff. ...

EAO: One thing I would actually disagree with the requiring on the inside of message format is requiring the functions for handling display elements.

What I've found is that if the output of the message format can be a structure, as it is currently the Intl.MessageFormat proposal,

then Intl.MessageFormat, does not need to know anything know how to handle a bold tag, but it needs to be able to provide an output that includes a bold tag with contents.

And, you know, there results and the values of those options that can then be processed by a further stage, effectively, the handling of, what do you do with a bold tag and its contents and be externalized away from message format output.

MIH: Who does that then?

EAO: The user of Int.MessageFormat React MF library or DOM MF formatting library that does needs to be able to provide a way of saying it.

MIH, EAO: (goes back and forth to understand the above statement)

ZBI: (posts a question from a customer as a mental expercise for the audience)

Okay, so, Contract.

EAO: Wraps up the meeting. My sense is we've reached some progress. I think we agreed on some differences existing between how placeholders are used and elements are used. We disagreed on wheter these use cases are sufficiently different to be represented in the data model by different constructs. We need to continue this discussion and we will. But I don't think we should next week be considering this topic. For next week we touched on it a little bit but if we don't have any other specific topic to comment on, I'd think we have a topic for further discussion on meta data and comments. To continue communicate information to localizers and partly the other uses that we can have for meta data. Is this suitable?

Bullets & issues we want to touch on are on issue 219.

(not next week - will be brought up for montly meeting discussion)
